
dus
Дмитрий Юрич соловей в переводе	
Ubuntu 22.04 LTS (WSL это Windows Subsystem for Linux)
Vs code
dus0182   FAM-fjB-Du7-Vbr
Dimonka4331
             
dus
#dus101MnhQ 

srv503956.hstgr.cloud

ssh user@host

Ditto программка для увеличения и просмотра буффера обмена

ssh-keygen -t rsa -b 4096
ssh-copy-id user@host


data-2024-04-07-03-00-01.csv

ssh dus@srv503956.hstgr.cloud
cd /home/programfid/app



cat "*.csv" | grep "/3[0-9];" > report1.txt


set -x
cat data-2024-04-07-03-00-01.csv | grep "/3[0-9];" > report.txt


find . -name "*.csv"
******************************************************
# поиск csv файлов, отбор по признаку свыше 30 года, сохранение в тхт файле
csvfiles=$(find . -name "*.csv")
for i in $csvfiles;do
cat $i | grep "/3[0-9];" >> report1.txt
done

tar –czvf arhiv.tar.gz $csvfiles

******************************************************
# поиск файлов старше суток до 100 дней

find / -mtime 1
find / -mtime +1 -mtime -100
******************************************************

# создать папку arhive скриптом (что бы проверял и делал если нет созданной)
# ошибка
arhive=$(find . -type d -name "arhive")
for n in $arhive; do
if [!-d ./$n]
then
mkdir ./$n
echo "директория_создана"
done
*******************************************
# создает каталог архив в директории

if [ ! -d "archive" ]; then
  mkdir -pv archive
fi
******************************************************
 tar –czvf myfiles.tar.gz myfiles/Templates  Эта команда упакует и сожмет все файлы в папке myfiles в сжатый архив с именем myfiles.tar.gz.  
 tar -c<опции> <новый архивный файл> <что сжимаем> ** где z — сжать архив в gzip 
(без этого параметра, tar не сжимает, а создает так называемый тарбол); c — ключ на создание архива;
 v — verbose режим, то есть с выводом на экран процесса (очень удобно для наблюдением за ходом работы,
 но в скриптах можно упустить); f — использовать файл (обязательно указываем, так как в большей степени работаем именно с файлами).

 tar -xzvf myfiels.tar.gz  Эта команда распакует архив.
 gzip * - заархивирует все файлы в архиве под их именами gzip -d * распакует
********************************************************
 find ./ -mtime +1 -mtime -100 -name "*csv"
*********************************************************
if [ ! -d "archive" ]; then
  mkdir -pv archive
fi
find ./ -mtime +1 -mtime -100 -name "*csv" -exec mv {} archive \;
cd archive
gzip *.csv

**********************************************************
 cd /etc/cron.d
 https://crontab.guru/#*_*_*_*_*
 cron - это системный процесс, который автоматически выполняет задачи для вас в соответствии
 с установленным расписанием.
 
 *********************************************************************
 Ps позволяет отображать и управлять процессами в операционной системе. 
Она предоставляет информацию о работающих процессах и позволяет мониторить их состояние. 
Также можно использовать команду ps для фильтрации и поиска конкретных процессов. 
Это полезная утилита для управления и анализа процессов в Linux.
 ps -u username 
 ps -C program
 ps aux | grep /home/programfid/app | grep -v grep | cut -d " " -f9
 sudo ps aux | grep nginx | grep -v grep
 sudo ps aux | grep /home/programfid/app | grep  -v grep


 kill --help
 kill -9 PID   Команда kill в Linux обеспечивает наиболее распространённый способ отправки сигналов процессам.
Эта команда принимает два аргумента: номер или имя сигнала и PID процесса, который надо завершить. Опция -s задаёт имя сигнала, а опция -n — номер сигнала. 
Если не указаны имя и номер сигнала, kill по умолчанию отправит сигнал 15, запрашивая завершение процесса.
 pkill process_name Замените process_name на имя процесса.

nice проверить текущий приоритет выполнения процесса (nice -n 10 команда от -20 до 19)	renice -n<новое_значение> -p<идентификатор_процесса> nice -n 5 sleep 10
| grep -v grep

sudo systemctl list-units Чтобы перечислить все модульные файлы в вашей системе
Включение и отключение служб Systemd позволяет включать или отключать службы, определяя, запускаются ли они автоматически во время загрузки. 
sudo systemctl enable <service_name> Чтобы включить службу, используйте enable. Чтобы отключить службу, используйте команду disable
Запуск и остановка служб
Вы также можете запустить или остановить службу немедленно, не влияя на ее состояние во время загрузки. Чтобы запустить службу, используйте start команду:
 sudo systemctl start <service_name>
 sudo systemctl stop <service_name>

 sudo systemctl status chronyd Для проверки статуса службы Chrony можно использовать команду sudo
 sudo systemctl cat chronyd (Chrony — это гибкая реализация протокола сетевого времени Network Time Protocol (NTP))
 chronyd — служба, которая может быть запущена во время загрузки системы.
 sudo systemctl --help

 nginx — это HTTP-сервер и обратный прокси-сервер, почтовый прокси-сервер, а также TCP/UDP прокси-сервер общего назначения, 
изначально написанный Игорем Сысоевым. Уже длительное время он обслуживает серверы многих высоконагруженных российских сайтов, таких как Яндекс, mail.ru, ВКонтакте и Рамблер
 — это программное обеспечение с открытым исходным кодом для создания веб-серверов. Оно принимает запрос клиента, например браузера, обрабатывает его и возвращает ответ

 sudo systemctl status nginx
 sudo yum install nginx
 sudo ps aux | grep nginx | grep -v grep
 sudo systemctl enable nginx
 systemctl start nginx
 systemctl stop nginx
 systemctl status nginx
 systemctl restart nginx
 systemctl is-enabled nginx Проверить добавлена ли уже служба nginx в автозагрузку:
 systemctl enable nginx Для добавления сервиса в автозагрузку используется
 systemctl enable --now nginx Чтобы включить и запустить службу одновременно
 systemctl mask nginx Можно также "замаскировать" сервис - то есть, лишить модуль возможности запускаться.  systemctl mask / systemctl unmask: запрещает (разрешает) все и 
любые попытки запуска рассматриваемого модуля (либо вручную, либо как зависимость любого другого модуля, включая зависимости цели загрузки по умолчанию).
 systemctl list-dependencies Посмотреть дерево зависимостей - от каких процессов зависит cron.
 systemctl Вывести список всех процессов
 systemctl -t service -a Список запущенны юнитов, без ключа -а будут показаны только те службы которые сейчас работают	
# systemctl list-units Список всех имеющихся модулей в системе покажет команда
# systemctl status syslog.target  Просмотр статуса службы, например syslog
syslog.target - Syslog  
	  Loaded: loaded (/lib/systemd/system/syslog.target; static)
	  Active: active since Thu, 01 Mar 2012 16:18:25 +0000; 18h ago


curl --help   $ curl опции ссылка А если вы хотите, чтобы полученный файл назывался так же, как и файл на сервере, используйте опцию -O:
curl -O (https://raw.githubusercontent.com/curl/curl/master/README.md)-ссылка
curl -X GET http://localhost:80
Теперь рассмотрим основные опции:
-# - отображать простой прогресс-бар во время загрузки;
-0 - использовать протокол http 1.0;
-1 - использовать протокол шифрования tlsv1;
-2 - использовать sslv2;
-3 - использовать sslv3;
-4 - использовать ipv4;
-6 - использовать ipv6;
-A - указать свой USER_AGENT;
-b - сохранить Cookie в файл;
-c - отправить Cookie на сервер из файла;
-C - продолжить загрузку файла с места разрыва или указанного смещения;
-m - максимальное время ожидания ответа от сервера;
-d - отправить данные методом POST;
-D - сохранить заголовки, возвращенные сервером в файл;
-e - задать поле Referer-uri, указывает с какого сайта пришел пользователь;
-E - использовать внешний сертификат SSL;
-f - не выводить сообщения об ошибках;
-F - отправить данные в виде формы;
-G - если эта опция включена, то все данные, указанные в опции -d будут передаваться методом GET;
-H - передать заголовки на сервер;
-I - получать только HTTP заголовок, а все содержимое страницы игнорировать;
-j - прочитать и отправить cookie из файла;
-J - удалить заголовок из запроса;
-L - принимать и обрабатывать перенаправления;
-s - максимальное количество перенаправлений с помощью Location;
-o - выводить контент страницы в файл;
-O - сохранять контент в файл с именем страницы или файла на сервере;
-p - использовать прокси;
--proto - указать протокол, который нужно использовать;
-R -  сохранять время последнего изменения удаленного файла;
-s - выводить минимум информации об ошибках;
-S - выводить сообщения об ошибках;
-T - загрузить файл на сервер;
-v - максимально подробный вывод;
-y - минимальная скорость загрузки;
-Y - максимальная скорость загрузки;
-z - скачать файл, только если он был модифицирован позже указанного времени;
-V - вывести версию.

*************************************************************************************
удалить файл /tmp/README

*************************************************************************************
 
 #ps aux | grep nohub | grep -v grep | cut -d " " -f1
 #ps aux | grep ./venv/bin/activate | grep -v grep | cut -d " " -f1
 #ps aux | grep ./run.sh | grep -v grep | cut -d " " -f1
 set -e

#cd /home/programfid/app; nohup pkill ./run.sh

Остановка запущенного процесса nohup посредством пинга
nohup ping linuxcookbook.ru &
pgrep -a ping
286725 ping linuxcookbook.ru
[dus@srv503956 app]$ kill 286725
[dus@srv503956 app]$ systemctl status nohup.target
Unit nohup.target could not be found.
[1]+  Terminated              nohup ping linuxcookbook.ru


#ps aux | grep /home/programfid/app | grep -v grep | cut -d " " -f9
********************************************************************************************
#stop.sh
stop=$(sudo ps aux | grep "flask run" | grep -v grep | cut -d " " -f7)
for i in $stop;do
kill -9 $i
echo "mesti svershilas - klient ubit"
done
sudo ps aux | grep "flask run" | grep -v grep | cut -d " " -f7
************Start.sh**************************************************************************
#!/usr/bin/bash
set -e
log=log-$(date +"%Y-%m-%d")
cd /home/programfid/app; nohup ./run.sh >> ./logs/$log &2>1 &

cd /home/programfid/app && source ./venv/bin/activate && flask run

****************вариант DUS********+++++++++++++++

[Unit]
Description=Test Bash Script in Systemd
After=network.target
[Service]
Type=simple
ExecStart=/home/programfid/app/app/start.sh
ExecStop=/home/programfid/app/app/stop.sh
[install]
WantedBy=multi-user.target

******************вариант asg*********************
[Unit]
Description=App flask
After=network.target
Wants=network-online.target

[Service]
WorkingDirectory=/home/programfid/app
ExecStart=/usr/bin/bash /home/asg/start.sh
Restart=always

[Install]
WantedBy=multi-user.target



/home/programfid/app
/usr/lib/systemd/system/ – юниты из установленных пакетов RPM — всякие nginx, apache, mysql и прочее
/run/systemd/system/ — юниты, созданные в рантайме — тоже, наверное, нужная штука
/etc/systemd/system/ — юниты, созданные системным администратором — а вот сюда мы и положим свой юнит.

Пользователь и группа, под которым надо стартовать сервис:
User=dus,asg
Group=programfid

#Обновить конфигурацию systemd:
$ systemctl daemon-reload

#Добавить сервис в автозагрузку и запустить его:
$ systemctl enable app.service
$ systemctl start app.service

#Проверьте что сервис запущен:
systemctl daemon-reload
$ systemctl status app.service
********************************************************************************************
# подключение к гитхабу
sudo apt-get update
sudo apt-get install wget ca-certificates
ssh-keygen -t rsa -b 4096
cd .ssh  (cat ~/.ssh/id_rsa.pub)
ls -la
cat id_rsa.pub
cd 	
https://git-scm.com/download   #- гит для винды устанавливается отдельно в программе VSCODE
git clone git@github.com:Dimonka2006/testapp.git
cd testapp
ls -la
#в ubunto вводим$ 
sudo apt install git
# CentOS
sudo yum install git
code . 
git config --global user.name "Dimonka2006"
git config --global user.email "Dimonka2006@mail.ru"

https://github.com/Dimonka2006/testapp.git   in HTML
git@github.com:Dimonka2006/testapp.git      in ssh
*************************
https://docs.docker.com/desktop/install/windows-install/  #"установка докера"
where is kill

lsattr -Для просмотра текущих аттрибутов

chattr -Эта утилита позволяет устанавливать и отключать атрибуты файлов, на уровне файловой системы не зависимо от стандартных (чтение, запись, выполнение)

$ chattr опции [оператор][атрибуты] файлы

Вот основные опции утилиты, которые вы можете использовать:

-R - рекурсивная обработка каталога;
-V - максимально подробный вывод;
-f - игнорировать сообщения об ошибках;
-v - вывести версию.
Оператор может принимать значения:

+ - включить выбранные атрибуты;
- - отключить выбранные атрибуты;
= - оставить значение атрибута таким, каким оно было у файла.
Вот некоторые доступные атрибуты:

a - файл может быть открыт только в режиме добавления;
A - не обновлять время перезаписи;
c - автоматически сжимать при записи на диск;
C - отключить копирование при записи;
D - работает только для папки, когда установлен, все изменения синхронно записываются на диск сразу же;
e - использовать extent'ы блоков для хранения файла;
i - сделать неизменяемым;
j - все данные перед записью в файл будут записаны в журнал;
s - безопасное удаление с последующей перезаписью нулями;
S - синхронное обновление, изменения файлов с этим атрибутом будут сразу же записаны на диск;
t - файлы с этим атрибутом не будут хранится в отдельных блоках;
u - содержимое файлов с этим атрибутом не будет удалено при удалении самого файла и потом может быть восстановлено.