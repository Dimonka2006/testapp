
ssh user@host

Ditto программка для увеличения и просмотра буффера обмена

ssh-keygen -t rsa -b 4096
ssh-copy-id user@host

ssh dus@srv503956.hstgr.cloud
cd /home/programfid/app


lsof  просмотреть файлы все открытые в системе
id -Gn - посмотреть в какой группе состою
data-2024-04-07-03-00-01.csv

ssh dus@srv503956.hstgr.cloud
cd /home/programfid/app
/etc/cron.d/programfid-app
1 * * * * programfid cd /home/programfid/app/ .arch.sh

cat "*.csv" | grep "/3[0-9];" > report1.txt
find . -maxdepth 1 -name "*.py" -printf " %f "

set -x
cat data-2024-04-07-03-00-01.csv | grep "/3[0-9];" > report.txt


find . -name "*.csv"
******************************************************
# поиск csv файлов, отбор по признаку свыше 30 года, сохранение в тхт файле
csvfiles=$(find . -name "*.csv")
for i in $csvfiles;do
cat $i | grep "/3[0-9];" >> report1.txt
done

tar –czvf arhiv.tar.gz $csvfiles

******************************************************
# поиск файлов старше суток до 100 дней

find / -mtime 1
find / -mtime +1 -mtime -100
******************************************************

# создать папку arhive скриптом (что бы проверял и делал если нет созданной)
# ошибка
arhive=$(find . -type d -name "arhive")
for n in $arhive; do
if [!-d ./$n]
then
mkdir ./$n
echo "директория_создана"
done
*******************************************
# создает каталог архив в директории

if [ ! -d "archive" ]; then
  mkdir -pv archive
fi
******************************************************
 tar –czvf myfiles.tar.gz myfiles/Templates  Эта команда упакует и сожмет все файлы в папке myfiles в сжатый архив с именем myfiles.tar.gz.  
 tar -c<опции> <новый архивный файл> <что сжимаем> ** где z — сжать архив в gzip 
(без этого параметра, tar не сжимает, а создает так называемый тарбол); c — ключ на создание архива;
 v — verbose режим, то есть с выводом на экран процесса (очень удобно для наблюдением за ходом работы,
 но в скриптах можно упустить); f — использовать файл (обязательно указываем, так как в большей степени работаем именно с файлами).

tar -lf 2024-05-20-11-53.tar.gz --list  просмотреть что в архиве

 tar -xzvf myfiels.tar.gz  Эта команда распакует архив.
 gzip * - заархивирует все файлы в архиве под их именами gzip -d * распакует
********************************************************
 find ./ -mtime +1 -mtime -100 -name "*csv"
*********************************************************
if [ ! -d "archive" ]; then
  mkdir -pv archive
fi
find ./ -mtime +1 -mtime -100 -name "*csv" -exec mv {} archive \;
cd archive
gzip *.csv

**********************************************************
 cd /etc/cron.d
 https://crontab.guru/#*_*_*_*_*
 cron - это системный процесс, который автоматически выполняет задачи для вас в соответствии
 с установленным расписанием.
 
 *********************************************************************
 Ps позволяет отображать и управлять процессами в операционной системе. 
Она предоставляет информацию о работающих процессах и позволяет мониторить их состояние. 
Также можно использовать команду ps для фильтрации и поиска конкретных процессов. 
Это полезная утилита для управления и анализа процессов в Linux.
 ps -u username 
 ps -C program
 ps aux | grep /home/programfid/app | grep -v grep | cut -d " " -f9
 sudo ps aux | grep nginx | grep -v grep
 sudo ps aux | grep /home/programfid/app | grep  -v grep


 kill --help
 kill -9 PID   Команда kill в Linux обеспечивает наиболее распространённый способ отправки сигналов процессам.
Эта команда принимает два аргумента: номер или имя сигнала и PID процесса, который надо завершить. Опция -s задаёт имя сигнала, а опция -n — номер сигнала. 
Если не указаны имя и номер сигнала, kill по умолчанию отправит сигнал 15, запрашивая завершение процесса.
 pkill process_name Замените process_name на имя процесса.

nice проверить текущий приоритет выполнения процесса (nice -n 10 команда от -20 до 19)	renice -n<новое_значение> -p<идентификатор_процесса> nice -n 5 sleep 10
| grep -v grep

sudo systemctl list-units Чтобы перечислить все модульные файлы в вашей системе
Включение и отключение служб Systemd позволяет включать или отключать службы, определяя, запускаются ли они автоматически во время загрузки. 
sudo systemctl enable <service_name> Чтобы включить службу, используйте enable. Чтобы отключить службу, используйте команду disable
Запуск и остановка служб
Вы также можете запустить или остановить службу немедленно, не влияя на ее состояние во время загрузки. Чтобы запустить службу, используйте start команду:
 sudo systemctl start <service_name>
 sudo systemctl stop <service_name>

 sudo systemctl status chronyd Для проверки статуса службы Chrony можно использовать команду sudo
 sudo systemctl cat chronyd (Chrony — это гибкая реализация протокола сетевого времени Network Time Protocol (NTP))
 chronyd — служба, которая может быть запущена во время загрузки системы.

 nginx — это HTTP-сервер и обратный прокси-сервер, почтовый прокси-сервер, а также TCP/UDP прокси-сервер общего назначения, 
изначально написанный Игорем Сысоевым. Уже длительное время он обслуживает серверы многих высоконагруженных российских сайтов, таких как Яндекс, mail.ru, ВКонтакте и Рамблер
 — это программное обеспечение с открытым исходным кодом для создания веб-серверов. Оно принимает запрос клиента, например браузера, обрабатывает его и возвращает ответ

 sudo systemctl status nginx
 sudo yum install nginx
 sudo ps aux | grep nginx | grep -v grep
 sudo systemctl enable nginx
 systemctl start nginx
 systemctl stop nginx
 systemctl status nginx
 systemctl restart nginx
 systemctl is-enabled nginx Проверить добавлена ли уже служба nginx в автозагрузку:
 systemctl enable nginx Для добавления сервиса в автозагрузку используется
 systemctl enable --now nginx Чтобы включить и запустить службу одновременно
 systemctl mask nginx Можно также "замаскировать" сервис - то есть, лишить модуль возможности запускаться.  systemctl mask / systemctl unmask: запрещает (разрешает) все и 
любые попытки запуска рассматриваемого модуля (либо вручную, либо как зависимость любого другого модуля, включая зависимости цели загрузки по умолчанию).
 systemctl list-dependencies Посмотреть дерево зависимостей - от каких процессов зависит cron.
 systemctl Вывести список всех процессов
 systemctl -t service -a Список запущенны юнитов, без ключа -а будут показаны только те службы которые сейчас работают	
# systemctl list-units Список всех имеющихся модулей в системе покажет команда
# systemctl status syslog.target  Просмотр статуса службы, например syslog
syslog.target - Syslog  
	  Loaded: loaded (/lib/systemd/system/syslog.target; static)
	  Active: active since Thu, 01 Mar 2012 16:18:25 +0000; 18h ago


curl --help   $ curl опции ссылка А если вы хотите, чтобы полученный файл назывался так же, как и файл на сервере, используйте опцию -O:
curl -O (https://raw.githubusercontent.com/curl/curl/master/README.md)-ссылка
curl -X GET http://localhost:80
Теперь рассмотрим основные опции:
-# - отображать простой прогресс-бар во время загрузки;
-0 - использовать протокол http 1.0;
-1 - использовать протокол шифрования tlsv1;
-2 - использовать sslv2;
-3 - использовать sslv3;
-4 - использовать ipv4;
-6 - использовать ipv6;
-A - указать свой USER_AGENT;
-b - сохранить Cookie в файл;
-c - отправить Cookie на сервер из файла;
-C - продолжить загрузку файла с места разрыва или указанного смещения;
-m - максимальное время ожидания ответа от сервера;
-d - отправить данные методом POST;
-D - сохранить заголовки, возвращенные сервером в файл;
-e - задать поле Referer-uri, указывает с какого сайта пришел пользователь;
-E - использовать внешний сертификат SSL;
-f - не выводить сообщения об ошибках;
-F - отправить данные в виде формы;
-G - если эта опция включена, то все данные, указанные в опции -d будут передаваться методом GET;
-H - передать заголовки на сервер;
-I - получать только HTTP заголовок, а все содержимое страницы игнорировать;
-j - прочитать и отправить cookie из файла;
-J - удалить заголовок из запроса;
-L - принимать и обрабатывать перенаправления;
-s - максимальное количество перенаправлений с помощью Location;
-o - выводить контент страницы в файл;
-O - сохранять контент в файл с именем страницы или файла на сервере;
-p - использовать прокси;
--proto - указать протокол, который нужно использовать;
-R -  сохранять время последнего изменения удаленного файла;
-s - выводить минимум информации об ошибках;
-S - выводить сообщения об ошибках;
-T - загрузить файл на сервер;
-v - максимально подробный вывод;
-y - минимальная скорость загрузки;
-Y - максимальная скорость загрузки;
-z - скачать файл, только если он был модифицирован позже указанного времени;
-V - вывести версию.

*************************************************************************************
удалить файл /tmp/README

*************************************************************************************
 
#cd /home/programfid/app; nohup pkill ./run.sh
Остановка запущенного процесса nohup посредством пинга
nohup ping linuxcookbook.ru &
pgrep -a ping
286725 ping linuxcookbook.ru
[dus@srv503956 app]$ kill 286725
[dus@srv503956 app]$ systemctl status nohup.target
Unit nohup.target could not be found.
[1]+  Terminated              nohup ping linuxcookbook.ru


#ps aux | grep /home/programfid/app | grep -v grep | cut -d " " -f9
***************************--------------************************************************
#stop.sh
stop=$(sudo ps aux | grep "flask run" | grep -v grep | cut -d " " -f7)
for i in $stop;do
kill -9 $i
echo "mesti svershilas - klient ubit"
done
sudo ps aux | grep "flask run" | grep -v grep | cut -d " " -f7
************---------**************************************************************************
#!/usr/bin/bash
set -e
log=log-$(date +"%Y-%m-%d")
cd /home/programfid/app; nohup ./run.sh >> ./logs/$log &2>1 &

cd /home/programfid/app && source ./venv/bin/activate && flask run

****************вариант DUS********+++++++++++++++

[Unit]
Description=Test Bash Script in Systemd
After=network.target
[Service]
Type=simple
ExecStart=/home/programfid/app/app/start.sh
ExecStop=/home/programfid/app/app/stop.sh
[install]
WantedBy=multi-user.target

**********************вариант asg*************************
[Unit]
Description=App flask
After=network.target
Wants=network-online.target

[Service]
WorkingDirectory=/home/programfid/app
ExecStart=/usr/bin/bash /home/asg/start.sh
Restart=always

[Install]
WantedBy=multi-user.target

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&--systemctl--&&&&&&&&&
#Обновить конфигурацию systemd:
$ systemctl daemon-reload

#Добавить сервис в автозагрузку и запустить его:
$ systemctl enable app.service
$ systemctl start app.service

#Проверьте что сервис запущен:
systemctl daemon-reload
$ systemctl status app.service
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
# подключение к гитхабу
sudo apt-get update
sudo apt-get install wget ca-certificates
                                
ssh-keygen -t rsa -b 4096      - для генерации ключей
cd .ssh  (cat ~/.ssh/id_rsa.pub)    - каталог с ключиком
ls -la
ssh-copy-id dus@srv503956.hstgr.cloud - внесение ключа на сервер, для входа без пароля

cat id_rsa.pub - публичный ключик
cd 	
https://git-scm.com/download   #- гит для винды устанавливается отдельно в программе VSCODE
git clone git@github.com:Dimonka2006/testapp.git
cd testapp
ls -la
#в ubunto вводим$ 
sudo apt install git
# CentOS
sudo yum install git
code . 
git config --global user.name "Dimonka2006"
git config --global user.email "Dimonka2006@mail.ru"

https://github.com/Dimonka2006/testapp.git   in HTML
git@github.com:Dimonka2006/testapp.git      in ssh
*************************
https://docs.docker.com/desktop/install/windows-install/  #"установка докера"
where is kill

lsattr -Для просмотра текущих аттрибутов

chattr -Эта утилита позволяет устанавливать и отключать атрибуты файлов, на уровне файловой системы не зависимо от стандартных (чтение, запись, выполнение)

$ chattr опции [оператор][атрибуты] файлы

Вот основные опции утилиты, которые вы можете использовать:

-R - рекурсивная обработка каталога;
-V - максимально подробный вывод;
-f - игнорировать сообщения об ошибках;
-v - вывести версию.
Оператор может принимать значения:

+ - включить выбранные атрибуты;
- - отключить выбранные атрибуты;
= - оставить значение атрибута таким, каким оно было у файла.
Вот некоторые доступные атрибуты:

a - файл может быть открыт только в режиме добавления;
A - не обновлять время перезаписи;
c - автоматически сжимать при записи на диск;
C - отключить копирование при записи;
D - работает только для папки, когда установлен, все изменения синхронно записываются на диск сразу же;
e - использовать extent'ы блоков для хранения файла;
i - сделать неизменяемым;
j - все данные перед записью в файл будут записаны в журнал;
s - безопасное удаление с последующей перезаписью нулями;
S - синхронное обновление, изменения файлов с этим атрибутом будут сразу же записаны на диск;
t - файлы с этим атрибутом не будут хранится в отдельных блоках;
u - содержимое файлов с этим атрибутом не будет удалено при удалении самого файла и потом может быть восстановлено.

****************************Отладка скриптов************************

Отладка Bash-скриптов может оказаться трудной задачей, поскольку проблемы могут быть вызваны различными факторами, такими как ошибки синтаксиса, неправильное использование переменных или функций и т.д. Для отладки Bash-скриптов можно использовать такие инструменты, как set -x, set -v и set -e. 

Команда set -x позволяет выводить на экран команды перед их выполнением, команда set -v выводит на экран значения переменных перед их использованием, а set -e прерывает выполнение скрипта в случае ошибки.
*****************************словарь программистов*************************
Баг — ошибка
Фича — особенность или возможность
Деплой — развёртывание или размещение
Реквест — запрос
Шерить — делиться
Продакшен, или прод, — рабочая среда или окружение
Скоуп — объём всех работ
Дебаг — отладка
Аффектить — влиять
Фиксить — исправлять
Комплитить — завершать задачу
Бэкенд — серверная часть
Бэклог — список задач
Апрувнуть — одобрять
Апгрейд и апдейт — обновление или улучшение
Бэкап — резервная копия
Дефолтный — базовый, по умолчанию
Таск, или таска, — задача
****************************************************************************************


#!/bin /bash
source_dir="/путь /к / источнику"
backup_dir="/путь /к /резервной копии"
timestamp =$(дата +%Y%m%d%H%M%S)
backup_file=backup_$timestamp.tar.gz
tar -czvf $backup_dir/$backup_file $source_dir


#!/bin /bash
source_dir="/home/programfid/app/"
backup_dir="/home/programfid/app/archive"
timestamp =$(date +%Y%m%d%H%M)
dfile=$(find . -maxdepth 1 -type f -name "*.sh" -o -name "*.py")
backup_file="$timestamp_$dfile.tar.gz"
tar -czvf "$backup_dir/$backup_file" "$dfile"
#find $backup_dir"*.tar.gz" -mtime +10 -exec rm {} \;



значит 
1 забекапить через ssh,
2 скопировать новый файл программы через ssh,
3 запустить службу,
4 проверить запуск



docker build --help
wsl --set-version Ubuntu-20.04 2   (update wsl)

whatis — дает однострочную справку к любой из установленных программ. Принцип работы следующий: вводим слово whatis, а за ним следом название приложения,
 о котором хотим узнать. Например, чтобы узнать о том, что такое nano, введем в терминал: whatis nano.

man название пакета — открывает документацию к любой из установленных программ. В ней можно посмотреть, какие функции есть у приложения, 
как им пользоваться, какие могут возникнуть проблемы.

history — показывает ранее использованные приложения и инструменты. Без дополнительных аргументов отображает 10 элементов. 
Но их количество можно изменить вручную, добавив к слову history любое число. history 13, к примеру.

scp — делает копии файлов с одного хоста на другом, задействуя протокол SSH. Синтаксис: scp имя пользователя@адрес сервера:путь до директории или документа, 
которые надо перенести путь до каталога, куда нужно отправить выбранные элементы. Немного запутанный, но если смотреть на пример, то будет легче: 
scp root@89.223.127.80:/home/timeweb/Desktop Documents/. Такая команда перенесет папку Desktop в директорию Documents.
scp [путь к файлу] [имя пользователя]@[имя сервера/ip-адрес]:[путь к файлу] 
scp /home/test.txt root@123.123.123.123:/directory пример команды
scp -r [источник] [получатель] Если вы хотите скачать папку со всеми файлами и подпапками, используйте ключ -r:

ssh dus@srv503956.hstgr.cloud

scp -P 22 backup_deploy.sh dus@srv503956.hstgr.cloud:/home/programfid/app    выложить на сервер

scp /home/programfid/app/stop.sh dus@srv503956.hstgr.cloud "/root"     directory пример команды

Синтаксис команды:

ssh [пользователь]@[сервер] ‘[команда]’
Kопировать
При запросе вводим пароль указанного пользователя и в консоли получаем вывод команды, если таковой имеется.
Например, получим информацию об установленной на удаленном сервере операционной системе:
ssh root@123.123.123.123 ‘uname -a’
Kопировать
Чтобы запустить несколько команд за одно подключение, можно использовать символ “;” в качестве разделителя. 
Проверим сетевые настройки и активные сетевые подключения на удаленном сервере:

ssh  root@123.123.123.123 ‘ifconfig; netstat -anp tcp’
Kопировать
В случае, если потребуется запустить на удаленном сервере локальный файла сценария, потребуется в SSH-подключении вызвать командный интерпретатор в 
режиме исполнения сценария (например, bash с ключом -s), и на стандартный ввод передать ему файл сценария. Выглядеть эта конструкция будет так:

ssh  root@123.123.123.123 ‘bash -s’ < /home/user/myscript.sh
Kопировать
В результате локальный файл /home/user/myscript.sh исполнится на удаленном сервере.

Запуск команды SSH без параметров позволит ознакомиться с краткой справкой по синтаксису и списком дополнительных модификаторов, которые позволяют расширить 
функциональность команды.


rsync — синхронизирует файлы между двумя или более хостами. При попытке синхронизировать аналогичные каталоги (как в предыдущем примере) получится следующий код: 
rsync root@89.223.127.80:/home/timeweb/temp Desktop/. Если добавить опцию -a, то утилита перейдет в режим архива и сделает полноценную копию всех элементов директории 
без изменений.

diff — сравнивает два файла и наглядно показывает строки, в которых обнаружились различия. Синтаксис: diff название первого файла название второго файла. 
Это может выглядеть так: 
diff timeweb-1.html timeweb-2.html


sudo journalctl - логи по имени по дате 
last -5 кто коннектился


find -daystart  
-daystart
              Measure times (for -amin, -atime, -cmin, -ctime, -mmin, and -mtime) from the beginning of today rather than from 24 hours ago.  
              This option only affects tests which appear later on the command line.

 -printf " %f "

echo "/filename" | sed 's/\///g'

scp -r directory user@remote_host[:dest_dir] 
rsync -a host:src_dir dest_dir скопировать с сервера директорию
rsync -nva dir user@host:dest_dir или через службу rsunc для передачи всей иерархии каталогов, включая символические ссылки, права доступа, режимы и устройства, 
используйте параметр -a скопировать на сервер